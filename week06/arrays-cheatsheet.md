# Масиви и низове

## Деклариране и инициализация

```c++
int arr[5]; // създаване на масив с 5 елемента от тип int
char arr[5]; // създаване на масив с 5 елемента от тип char
int arr[]; // не е разрешено - не е ясно колко памет да се задели

int arr[3] = {1, 2, 3}; // създаване на масив с 3 елемента от тип int и задаване стойностите на елементите с инициализиращ списък
int arr[] = {1, 2, 3}; // същото като горното - компилаторът се досеща, че размерът е 3
int arr[5] = {1, 2, 3}; // създаване на масив с 5 елемента от тип int и задаване стойностите на елементите на първите 3 - останалите получават default-на стойност 0
char arr[6] = {'g', 'r', 'o', 'u', 'p', '3'}; // пример с масив с елементи от тип char
bool arr[3] = {true, false, true}; // пример с масив с елементи от тип bool

int arr[3] = {1, 2, 3, 4}; // това води до грешка - опитваме се да поберем 4 елемента в масив за 3
```

## Достъпване на елемент

```c++
int arr[4] = {1, 2, 3};
// Индексирането започва от 0. Първият елемент е на позиция 0 в масива, последният елемент е на позиция l - 1, където l e дължината на масива
arr[0] // 1
arr[1] // 2
arr[2] // 3
arr[3] // 0 -> default-на стойност
arr[-1] // В c++ няма проверка за коректност на индекс. Този код ще се компилира и ще доведе до недефинирано поведение.
arr[13] // В c++ няма проверка за коректност на индекс. Този код ще се компилира и ще доведе до недефинирано поведение.

arr[0] = 12; // Можем да презписваме стойност на елемент
std::cout << arr[1] + arr[2]; // Можем да използваме елементите на масив в израз
arr[arr[1]]; // Можем да ги ползваме и като индекс

```


## Въвеждане от стандартния вход

```c++
int arr[20];
int n;
std::cin >> n;

// Проверка за коректност, за да сме сигурни, че няма да излезем от границите на паметта заделена за масива.
if (n >= 0 && n < 20)
{
    for(int i = 0; i < n; i++)
        std::cin >> arr[i];
}
```

Код, който не се компилира:
```c++
int arr[20];
std::cin >> arr;
```

> **Забележка** - следващия блок от код се компилира с някои компилатори(например gcc), които поддържат масиви с променлива дължина като функционалност. Тази функционалност обаче **не** е част от C++ стандарта, затова ще я избягваме и няма да я ползваме. Размерът на масива трябва да е ясен по време на компилация, т.е. той трябва да е някаква константа.

```c++
int n;
std::cin >> n;
int arr[n];
```


## Симовлни низове

```c++
char arr[] = "group3"; // можем да ги инициализираме от стрингова константа
char arr[7] = {'g', 'r', 'o', 'u', 'p', '3', '\0'}; // това е еквивалентно на горното
char arr[7] = {'g', 'r', 'o', 'u', 'p', '3'}; // това също е еквивалентно на горното, защото последния елемент в масива ще получи default-на стойност 0
char arr[] = {'g', 'r', 'o', 'u', 'p', '3'}; // това не е еквивалентно на горните 3 - това е масив със 6 елемента и няма терминираща нула накрая
```

```c++
char arr[20];
std::cin >> arr;  // Можем да ги въвеждаме дирекнто от клавиатурата(а не елемент по елемент). Резултатният масив автоматично ще има терминираща нула на края. Елементите на масива ще са всички символи, които сме въвели от клавиатурата до натискане на разделителен символ(например space или нов ред).
```

> **Забележка** - когато използваме `std::cin >> arr`, няма проверка за границите на масива. Ако въведем повече от 20 символ, те ще бъдат записани в паметта, което означава, че нашата програма ще пипа памет, която не е заделила експлицитно.

```c++
char arr1[3];
char arr2[3];
std::cin >> arr2 >> arr1; // ако въведем "group 3" от стандартния вход
std::cout << arr2; // ще видим, че това отпечатва на екрана "gro3"
```

```c++
char arr[10];
std::cin.getline(arr, 10); // Затова ползваме функцията getline. Елементите на масива ще са всички символи, които въведем, до натискане на нов ред или докато не въведем 9 символа(10ия ще е термниращата нула). Така си гарантираме, че няма да прескочим паметта, която сме заделили за нашия масив.
```


```c++
char arr[] = "group3";
std::cout << arr; // Елементите на масива можем да отпечатаме директно без цикъл. Ще бъдат отпечатани всички елементи до първата термнираща нула в масива.

char arr[] = {'g', 'r', 'o', 'u', '\0', 'p', '3', '\0'};
std::cout << arr; // На екрана ще видим "grou"
```

## Масиви като параметри на функции

```c++
// Подаваме два параметъра - масивът и реалният му размер
void printArray(int arr[], int n)
{
    for (int i = 0; i < n; i++)
        std::cout << arr[i];
}

// Аналогична функция на предната. Няма значение какво число сложим като размер. Виж обяснението по-долу
void printArray(int arr[50], int n)
{
    for (int i = 0; i < n; i++)
        std::cout << arr[i];
}

// При символните низове няма да подаваме допълнителен параметър за размера на масива, защото знаем, че той завършва с терминираща нула.
void printCharArray(char arr[])
{   
    int i = 0;
    while(arr[i])
    {
        std::cout << arr[i];
        i++;
    }
}

int main()
{
    int arr[] = {1, 2, 3};
    printArray(arr, 3);   
}
```

Масивът не се копира при извикване на функцията. Това което реално се подава към функцията е указател към първия елемент на масива.

```c++
void modfiyArray(int arr[], int n)
{
    arr[0] = 5;
}

int main()
{
    int arr[] = {1, 2, 3};
    modfiyArray(arr, 3);   
    std::cout << arr[0]; // Отпечатва 5 на екрана.
}
```

## Вградени функции за работа със символни низове

https://classes.mst.edu/compsci1570/ntcafunctions.htm

```c++
// strlen - дава размерът на низа
char arr[] = "Hello";
std::cout << strlen(arr); // 5

// strcmp - сравнява лексикографски двата низа и връща отрицателно число, ако първият е по-малък лексикографски, 0 ако двата низа са еднакви и положително число, ако първият е по-голям лексикографски
char arr1[] = "Hello";
char arr2[] = "Hello World!";
char arr3[] = "hello";
std::cout << strcmp(arr1, arr2); // отрицателно число
std::cout << strcmp(arr3, arr1); // положително число
std::cout << strcmp(arr1, arr1); // нула

// strcpy - копира съдържанието на втория низ в първия
char arr[10];
char arr1[] = "Hello";
strcpy(arr, arr1);
std::cout << arr; // Hello
```


## Непозволени операции

```c++
int arr1[] = {1, 2, 3};
int arr2 = arr1; // грешка

int arr1[] = {1, 2, 3};
int arr2[] = {1, 2, 3, 4};
arr1 = arr2; // грешка


int arr1[] = {1, 2, 3};
int arr2[] = {1, 2, 3, 4};
std::cout << arr1 + arr2; // грешка


int arr1[] = {1, 2, 3};
int arr2[] = {1, 2, 3};
if (arr1 == arr2) // Не това е начинът да сравним два масива. Този израз винаги ще се оцени на false.
{
    std::cout << "The arrays are equal";
}
else
{
    std::cout << "The arrays are not equal";
}
```
